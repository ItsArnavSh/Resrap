package resrap

import (
	"errors"
	"fmt"
)

type token struct {
	id   uint32 //Will be generated by the parser
	typ  tokenType
	text string //Generated by the Scanner
}

type tokenType int8

const (
	character tokenType = iota //Normal words
	//'...'
	maybe       //?
	oneormore   //+
	anyno       //*
	bracks      //(...)
	option      // |
	padding     //just to account for my bad indexing skills
	regexrange  //[...]
	infinite    //^
	probability //<...>
	identifier  //Normal words
	str         //'...'
	regex       //[...]
	bracopen    //(
	bracclose   //)
	colon
	semicolon
)

func (t tokenType) String() string {
	switch t {
	case character:
		return "character"
	case maybe:
		return "maybe"
	case oneormore:
		return "oneormore"
	case anyno:
		return "anyno"
	case bracks:
		return "bracks"
	case option:
		return "option"
	case padding:
		return "padding"
	case regexrange:
		return "regexrange"
	case infinite:
		return "infinite"
	case probability:
		return "probability"
	case identifier:
		return "identifier"
	case str:
		return "str"
	case regex:
		return "regex"
	case bracopen:
		return "bracopen"
	case bracclose:
		return "bracclose"
	case colon:
		return "colon"
	case semicolon:
		return "semicolon"
	default:
		return fmt.Sprintf("tokenType(%d)", int(t))
	}
}

type graphbuilder struct {
	grammar string
	pars    parser
	tokens  []token
}

func newGraphBuilder() graphbuilder {
	return graphbuilder{
		pars: new_parser(),
	}
}
func (g *graphbuilder) start_generation(grammar string) error {
	g.grammar = grammar
	return g.generate_graph()

}
func (g *graphbuilder) generate_graph() error {
	tokens, scanErrs := extracttokens(g.grammar)

	if len(scanErrs) != 0 {
		var all []error
		for _, err := range scanErrs {
			all = append(all, fmt.Errorf("ERROR Scanning grammar >>> %s", err.Msg))
		}
		return errors.Join(all...)
	}
	g.pars.tokens = tokens
	g.pars.graph.charmap = g.pars.charmap
	g.pars.graph.namemap = g.pars.name_map
	g.pars.graph.regexhandler = g.pars.regexhandler
	g.pars.parse_grammar()

	var all []error

	// collect parse errors
	for _, err := range g.pars.errors {
		all = append(all, fmt.Errorf("ERROR Parsing >>> %s", err.Error()))
	}

	// collect validation errors
	for _, err := range g.pars.ValidateGraph() {
		all = append(all, fmt.Errorf("ERROR Validating >>> %s", err.Error()))
	}

	if len(all) > 0 {
		return errors.Join(all...)
	}
	return nil
}
